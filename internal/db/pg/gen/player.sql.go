// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: player.sql

package pg

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO player (name, email, password) VALUES ($1, $2, $3) RETURNING id, name, points, email, password, is_deleted
`

type CreatePlayerParams struct {
	Name     string
	Email    string
	Password string
}

func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (*Player, error) {
	row := q.db.QueryRow(ctx, createPlayer, arg.Name, arg.Email, arg.Password)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Points,
		&i.Email,
		&i.Password,
		&i.IsDeleted,
	)
	return &i, err
}

const deletePlayer = `-- name: DeletePlayer :exec
UPDATE player SET is_deleted = true WHERE id = $1
`

func (q *Queries) DeletePlayer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePlayer, id)
	return err
}

const getPlayerByEmail = `-- name: GetPlayerByEmail :one
SELECT id, name, points, email, password, is_deleted FROM player WHERE email = $1
`

func (q *Queries) GetPlayerByEmail(ctx context.Context, email string) (*Player, error) {
	row := q.db.QueryRow(ctx, getPlayerByEmail, email)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Points,
		&i.Email,
		&i.Password,
		&i.IsDeleted,
	)
	return &i, err
}

const getPlayerByID = `-- name: GetPlayerByID :one
SELECT id, name, points, email, password, is_deleted FROM player WHERE id = $1
`

func (q *Queries) GetPlayerByID(ctx context.Context, id uuid.UUID) (*Player, error) {
	row := q.db.QueryRow(ctx, getPlayerByID, id)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Points,
		&i.Email,
		&i.Password,
		&i.IsDeleted,
	)
	return &i, err
}

const getPlayerByName = `-- name: GetPlayerByName :many
SELECT id, name, points, email, password, is_deleted FROM player WHERE name ILIKE '%' || $1 || '%'
`

func (q *Queries) GetPlayerByName(ctx context.Context, dollar_1 sql.NullString) ([]*Player, error) {
	rows, err := q.db.Query(ctx, getPlayerByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Points,
			&i.Email,
			&i.Password,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerGames = `-- name: GetPlayerGames :many
SELECT game.id, game.invite_id, game.word, game.player_count, game.start_time, game.end_time,
     gs.word_length,
     gs.trials,
     gs.max_player_count,
     gs.has_analytics,
     gs.should_record_time,
     gs.can_view_opponents_sessions
 from game
     INNER JOIN game_settings gs on gs.game_id = game.id
     INNER JOIN player_games pg ON game_player.game_id = game.id
     WHERE pg.player_id = $1
`

type GetPlayerGamesRow struct {
	ID                       uuid.UUID
	InviteID                 string
	Word                     string
	PlayerCount              int16
	StartTime                time.Time
	EndTime                  sql.NullTime
	WordLength               sql.NullInt16
	Trials                   sql.NullInt16
	MaxPlayerCount           sql.NullInt16
	HasAnalytics             sql.NullBool
	ShouldRecordTime         sql.NullBool
	CanViewOpponentsSessions sql.NullBool
}

func (q *Queries) GetPlayerGames(ctx context.Context, playerID uuid.NullUUID) ([]*GetPlayerGamesRow, error) {
	rows, err := q.db.Query(ctx, getPlayerGames, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPlayerGamesRow
	for rows.Next() {
		var i GetPlayerGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.InviteID,
			&i.Word,
			&i.PlayerCount,
			&i.StartTime,
			&i.EndTime,
			&i.WordLength,
			&i.Trials,
			&i.MaxPlayerCount,
			&i.HasAnalytics,
			&i.ShouldRecordTime,
			&i.CanViewOpponentsSessions,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayersResultCountInGame = `-- name: GetPlayersResultCountInGame :one
SELECT COUNT(*) from player_games pg WHERE pg.game_id = $1
`

func (q *Queries) GetPlayersResultCountInGame(ctx context.Context, gameID uuid.NullUUID) (int64, error) {
	row := q.db.QueryRow(ctx, getPlayersResultCountInGame, gameID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPlayersResultInGame = `-- name: GetPlayersResultInGame :many
SELECT player.id, player.name, player.points, player.email, player.password, player.is_deleted from player_games pg
     INNER JOIN player ON player.id = pg.player_id
     WHERE pg.game_id = $1
`

func (q *Queries) GetPlayersResultInGame(ctx context.Context, gameID uuid.NullUUID) ([]*Player, error) {
	rows, err := q.db.Query(ctx, getPlayersResultInGame, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Points,
			&i.Email,
			&i.Password,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
